

context UseCase {

	//verifica se um use case tem o nome vazio
	constraint UseCaseEmptyName {
	
		check: self.name != null and self.name.trim() != ""

		message: "Caso de Uso com nome vazio."
	
	}
	
	//verifica se um use case profundidade de include superior a 3
	critique NotIncludeInInclude {
	
		check: self.includedepth() < 3

		message: "Caso de Uso " + self.name + " possui uma profundidade de include superior a 2."
	
	}
	
	//verifica se o use case tem um verbo no nome
	constraint HasUseCaseNounAndVerb {
	 
		check: self.checkNameVerbNoun()

		message: "O nome do use case " + self.name + " não possui um verbo e um nome."
	
	}

}

context Actor {

	//verifica se um ator tem o nome vazio
	constraint ActorEmptyName {
	
		check: self.name != null and self.name.trim() != ""

		message: "Ator com nome vazio."
	
	}

}

//verifica se existem atores sem associacao
constraint ActorsWithoutAssociation {
	
	check: actorsWithNoAssociation().size() == 0

	message: "Existem Atores sem Associação."
	
}

//verifica se estão a ser usados links use em contexto de use case
constraint DoesUseCasehasVerbInName {
	
	check: Usage.getAllOfType() == 0

	message: "Links Usage inválidos no contexto de Use Cases."
	
}


//operacao que devolve profundidade de include
@cached
operation UseCase includedepth() : Integer {
  if (self.include.size() == 0) {
    return 0;
  }
  else {
    return 1 + self.include.get(0).addition.includedepth();
  }
}

//operacao que devolve atores sem associacao
operation actorsWithNoAssociation() : Set {
  	var allActors = Actor.getAllOfType().asSet();

	var associations = Association.getAllOfType();
	var actorsWithAssocitation = new Set();

	for(a : Association in associations){
		var end1 = a.ownedEnd.get(0).type;
		if(end1.isTypeOf(Actor)){
			actorsWithAssocitation.add(end1);
		}
	
		var end2 = a.ownedEnd.get(1).type;
		if(end2.isTypeOf(Actor)){
			actorsWithAssocitation.add(end2);
		}
	
	}
	
	return allActors.excludingAll(actorsWithAssocitation);
}

operation UseCase checkNameVerbNoun() : Boolean {

	var verbInSentence : Boolean = false;
	var nounInSentence : Boolean = false;

	var splitedName = self.name.split(" ");
	splitedName.println();
	
	for(s : String in splitedName){
	
		var url =  new Native("java.net.URL")("https://www.dictionaryapi.com/api/v3/references/thesaurus/json/" + s + "?key=4c831ba9-3885-42e6-8712-ddb5149b7534");
		
        // Open a connection(?) on the URL(??) and cast the response(???)
        var connection : Native("java.net.HttpURLConnection") = url.openConnection();

        // Now it's "open", we can set the request method, headers etc.
        connection.setRequestProperty("accept", "application/json");

        // This line makes the request
        var responseStream : Native("java.io.InputStream")  = connection.getInputStream();
        
		var streamReader = new Native("java.io.InputStreamReader")(responseStream);
        var bufferedReader = new Native("java.io.BufferedReader")(streamReader); 
        
       	var Collectors = Native("java.util.stream.Collectors");
       	var result : String = bufferedReader.lines().collect(Collectors.joining("\n"));
        result.println();
         
       	if("\"fl\":verb".isSubstringOf(result)){
       		verbInSentence = true;
       	}else if("\"fl\":noun".isSubstringOf(result)){
       		nounInSentence = true;
       	}
      }
	
	return verbInSentence and nounInSentence;
	
}
